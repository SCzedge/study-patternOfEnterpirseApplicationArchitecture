
# chap03
## 데이터 베이스 매핑
데이터 원본 계층의 역활은 애플리케이션이 작업을 수행하는데 필요한 인프라와 통신하는것이다.

## 아키텍쳐 패턴
패턴은 설계에 미치는 파급효과가 크고 리팩터링 하기 어려우므로 선택에 주의하여야 하며 도메인논리 설계에도 영향을 받는다.

sql의 접근을 도메인논리와 분리하여 개별 클래스에 배치하는것이 좋으며 테이블당 하나의 클래스를 구성하여 테이블의 게이트웨이가 되게 한다.

1. 행 데이터 게이트웨이 : 행마다 인스턴스가 있으며, 객체지향과 잘어울림
2. 테이블 데이터 게이트웨이 : 테이블마다 인스턴스가 있으며, 레코드 집합과 잘어울림

간단한 애플리케이션의 도메인모델은 일반적으로 복잡하지 않은 논리구조를 포함하는 경우가 많으므로 활성레코드 구조를 통해 도메인 객체가 직접 데이터베이스 작업을 수행하는것이 적절하다

그러나 도메인 논리가 복잡해지면 깔끔한 객체지향 패턴을 적용하기 어려우며 데이터베이스와 상호작용하지 않고도 도메인 논리를 테스트하는 방법이 필요하다. 따라서 간접계층을 통해 도메인 모델을 데이터베이스로부터 격리하는것이 나은방법이다.

이러한 패턴은 상호 배타적인것이 아니므로 혼합하여 사용할 수 있다.

객체 지향 데이터베이스는 복잡한 도메인 모델도 간단하게 저장할 수 있으며, 매핑을 신경쓰지 않고 객체를 저장하고 가져오는 작업을 데이터베이스가 알아서 처리할 수 있다. 이는 생산성 향상을 불러오지만 성능과 신뢰성 문제로 널리 사용되고 있지는 않다.

객체 지향 데이터베이스를 사용할 수 없을때는 ORM을 이용해 시간과 비용을 절감 할 수 있지만 ORM을 튜닝하고 사용하는데도 적지 않은 시간이 들며 이러한 패턴을 충분히 숙지하여 효율적으로 사용하여야 한다.

## 동작문제
동작문제는 객체가 데이터베이스에 저장 및 로드되는 방법에 대한것이다.

다수의 객체를 다룰때는 데이터베이스에 올바르게 기록하기위해 수정한 객체를 모두 추적하게 되는데 객체의 수가 많거나 여러 행을 다루게되면 문제가 복잡해진다.

또한 객체를 수정하는동안 데이터베이스의 상태를 일관되게 유지해야 하는데 이는 동시성이라는 매우 까다로운 문제이다.

### 작업단위
작업단위는 이 문제를 해결하는데 필요한 패턴이다.

작업단위는 수정한 객체를 추적하여 데이터베이스를 업데이트한다. 프로그래머는 저장메서드를 직접 호출하지 않고 작업단위에 요청하면 적절한 순서로 정리 후 작업을 한곳에서 처리한다.

데이터베이스 매핑의 컨트롤러로 작동하는 객체라고 생각하면 쉽다.

### 식별자 맵
같은객체를 중복으로 로드하고 모두 업데이트하게되면 예기치 못한 결과가 발생하므로 읽은 행을 식별자 맵을 이용해 추적하고 중복 데이터는 데이터에 대한 참조를 반환한다.  
또한 데이터베이스에 캐시를 늘려 호출을 줄여 성능이 향상되지만 주요 용도는 성능향상이 아닌 식별자를 올바르게 유지하는것이다.

### 지연 로드
객체가 복잡하게 연결된 경우 객체를 읽을때 연관객체의 양이 너무많을 수 있다.  
객체 참조 대신 지연로드의 자리 표시자(placeholder)를 이용해 링크를 따라가 실제 객체를 가져오게 하면 비효율을 방지 할 수 있다.

## 데이터 읽기
검색 메서드의 위치는 인터페이스 패턴에 따라 달라진다.

데이터베이스 상호작용 클래스가 테이블기반인경우 검색기메서드를 삽입 업데이트와 결합가능하나 클래스가 행기반인경우 불가하며 테스트시 스텁으로 대체할 수 없다.  
이경우 검색기 객체를 별도 구성하는것이 좋지만 주의할 점은 객체가 아닌 데이터베이스 기준으로 작업한다는것이다.

데이터를 읽을때는 같은 테이블에서 여러번 쿼리하는것보다 한번에 뽑은뒤 처리하는것이 성능면에서 이득이며 데이터베이스 접근을 줄이기 위해 조인을 사용하는경우도 있다.
또한 다양한 최적화가 가능하므로 알아볼것.


## 구조적 매핑 패턴
### 관계 매핑
객체와 관계형 데이터베이스가 연결을 처리하는 방법에는 차이가 있다.
1. 참조 방법 차이
    객체는 참조를 저장하지만 데이터베이스는 다른 테이블에 대한 키를 생성해 연결을 처리한다. 
2. 객체는 컬렉션을통해 여러 참조가 가능하나, 관계형은 정규화를 위해 연관링크가 같은값을 가져야한다.


해결방법은 객체의 관계형 식별자를 객체의 식별자 필드로 유지하여 키간 매핑을 처리하면 된다. 키가 없을떄는 데이터베이스에서 가져오거나 지연로드를 사용.


#### 컬렉션 관계 매핑
컬렉션 처리시 원본 객체의 id와 연결된 행을 찾기위해 추가 쿼리를 수행해 추가한다. 이과정은 복잡해질 수 있으나 익숙해지면 반복작업에 불과하다. 대규모 시스템에서는 메타데이터 기반의 처리방법을 사용하는것이 합리적이다.

다대다 컬렉션 관계를 처리시 연관 테이블 매핑을 사용해 새 관계형 테이블 생성.

컬렉션 사용시 컬렉션의 순서에 의존하면 테스트가 쉬워지나 저장시 순서를 유지하기는 매우 어렵다. 또한 정렬순서를 지정하면 성능에 지장이 갈 수 있으므로 순서없는 집합 사용을 고려하여야한다.

#### 참조 무결성 업데이트
참조 무결성 때문에 업데이트가 복잡해 질 수 있다. 참조 무결성 검사를 트랜잭션 끝으로 연기하는 기능이 있다면 사용하는것이 권장되지만 올바른 순서로 업데이트 되도록 주의하여야한다.

#### 작은값 객체
날짜나 금액같은 작은값 객체는 별도테이블이아닌 연결 객체에 포함값으로 넣으면 된다. 

#### 대규모 수행
객체 클러스터를 lob로 저장할 수 있다. 계층 객체일 경우엔 xml로 직렬화해 넣고 sql안에 xpath 쿼리식을 사용 할 수 있으나 대부분 비표준이므로 저장된 구조를 부분적으로 쿼리할 필요가 없는경우에 적합하다.

### 상속
- sql에는 상속을 처리하는 방법이 없으므로 매핑을 이용하여야한다.
- 자료구조의 중복과 접근 속도의 차이
- 상호 배타적이지 않으므로 패턴 혼합가능하나 복잡도 상승.
- 가장 좋은방법은 dba에게 문의.

#### 단일 테이블상속
- 계층의 모든 클래스에 테이블 하나 사용
- 모든정보가 한곳에 있으므로 수정이 쉽고 조인이없음
- 하위 형식의 열이 필요하므로 공간낭비가 발생
- 큰 크기로 인해 접근시 병목현상 발생가능

#### 구현 테이블 상속
- 구현 클래스당 테이블 하나 사용
- 상위 클래스 변경시 테이블과 매핑코드 변경이 필요하므로 변경에 취약
- 상위 클래스 테이블이 없어 키관리가 불편하며 참조무결성 유지가 어려움
- 상위 클래스 테이블에서 잠금 경합 감소

#### 클래스 테이블 상속
- 계층 클래스당 테이블 하나 사용
- 단일객체 로드시 여러번 조인하므로 성능이 낮음

## 매핑
매핑시 세가지 상황이 있다.
1. 스키마 선택가능
2. 변경 불가능한 기존스키마 사용
3. 변경 가능한 기존 스키마 사용

### 스키마 선택가능
가장 간단한 경우는 스키마를 직접 만들고 트랜잭션 스크립트나 테이블 모듈을 사용하는경우.

도메인 모델 사용시에는 데이터베이스를 염두하지 않고 도메인 논리를 간소화 하는데 집중하여야 하지만 개발 반복 주기를 단기로 설정한다.

### 기존스키마 사용
도메인 논리가 간단할경우 데이터베이스를 모방하는 행 데이터 게이트웨이나 테이블 데이터 게이트웨이 위에 도메인 논리 배치.  
복잡할 시에는 도메인모델과 데이터 매퍼를 사용하면된다.

### 이중매핑
1. 여러 데이터베이스에 동일 데이터가 저장되지만 스키마가 차이나는경우
2. 메커니즘이 다른경우

가장 간단한 방법은 원본마다 하나씩 매핑을 여러 계층으로 만드는 것이지만 코드 중복이 심해질 수 있다. 이경우 2단계 매핑 스키마를 고려한다.

#### 2단계 매핑스키마
1. 데이터를 인메모리 스키마에서 논리 데이터 저장소 스키마로 변환
2. 논리 데이터 저장소 스키마에서 물리 데이터 저장소 스키마로 매핑하며 차이해결.

## 메타데이터 사용
메타데이터 매핑은 데이터베이스의 컬럼이 객체의 필드에 매핑되는 방법을 기록해두는것이다. 

메타 데이터 매핑은 인메모리 객체를 얻는 쿼리를 작성하는데 필요한 정보를 제공한다. 

## 데이터 베이스 연결
데이터 베이스 연결 비용을 줄이기 위해 풀을 사용하는경우가 많다. 플랫폼에서 제공하므로 직접 할 필요는 없으나, 직접 할시에는 풀링이 성능에 도움이 되는지 확인해야한다.

풀 지원 환경에서 사용 여부를 완전히 캡슐화하는 경우가 있는데 바람직한 경우이다.

연결은 비용이든다.  
일반적인 조언은 풀이나 연결 관리자를 호출해 명시적으로 열고 닫는것이다. 이는 필요한 모든곳에서 연결을 확보해야하며, 작업이 끝나면 잊지않고 닫아야 한다는것이다.

필요한 곳에서 연결을 확보하는방법은 명시적 매개변수로 연결을 전달하는것이다.

명시적으로 연결을 닫는 방법은 문제의 여지가 많지만 가비지컬렉션은 이를 보완해줄 수 있다. 

연결은 트랜잭션과 밀접하므로 같이 관리하는것도 좋은방법이다. 트랜잭션 실행시 연결하고 커밋이나 롤백시 닫는다. 이 방법을 사용시 작업 단위가 적합하다.

## 기타 주의사항
select * from 구문을 사용시 드라이버에서 오류가 발생할 수 있으며 위치인덱스와 같이 사용하는것은 권장되지 않다. 하지만 열 이름 인덱스와 사용하는것은 괜찮으나 성능이 저하될수있으니 직접 측정하는것이좋다.













