# chap05
## 동시성
동시성은 소프트웨어 개발에서 가장 까다로운 측면 중하나다. 
문제의 원인을 미리 알기 어려워 해결이 힘들고 테스트하기도 어렵다.

트랜잭션은 까다로운 동시성의 여러 측면을 예방하는 프레임워크를 제공하므로 트랜잭션 내에서 조작을 수행하면 대부분 예방이 가능하다.
하지만 단일 트랜잭션에 넣을 수 없는 시스템과 상호 작용이 많기 때문에 완전히 무시할 수 없다.
여러 트랜잭션에 걸쳐 조작되는 경우 직접 동시성을 관리해야 하기 떄문이다.
여러 데이터베이스 트랜잭션에 걸쳐 조작되는 데이터에 대한 동시성제어를 오프라인 동시성이라고 한다.

또 다른 까다로운 문제는 다중 스레드 지원 서버 시스템인데 대처가 훨씬 수월하며 일부 서버 플랫폼은 거의자동으로 해결해준다.

이 책에서는 동시성 문제에 대한 해결책을 제안하는것이 아니다. 동시성 문제를 소개하고 오프라인 동시성을 해결하기위한 패턴을 소개하고
어플리케이션 서버 동시성에 대해 간단하게 알아본다. 또한 소스코드 관리 시스템을 예로 설명한다.

## 동시성문제
손실된 업데이트  
한사람이 파일을 수정하는동안 다른사람이 같은 파일을 수정하고 업데이트 한뒤에 업데이트하면 중간에 업데이트된 버젼을 
덮어쓰므로 이 내용은 사라지게된다.

일관성 없는 읽기  
한 사람이 데이터를 읽고 다른일을 처리하는 중 원본데이터가 업데이트 되었지만 일부만 추가로 읽는경우 발생한다.
업데이트 하기전 내용도아니고 업데이트 후 내용도 아닌 내용이되는데 이는 읽은 데이터에 일관성이 없기때문이다.

이 두 문제는 정확성을 위반하는 동작을 유발하지만 동시에 동일한 데이터를 사용하려고 하지 않는다면 발생하지않는다.
정확성만 중요하게 생각한다면 조율을 통해 한 사용자만 동시에 데이터를 사용할 수 있게 하면되지만 성능은 저하된다.

동시성이 얼마나 많이 진행될 수 있는지를 나타내는 활동성도 충족해야 하는데 필요성을 감안해 정확성을 양보하고 활동서을 향상시키는 경우도 있다.

## 실행 컨텍스트
외부 상호작용관점에서 중요한 컨텍스트 중 요청과 세션이 있다.  

요청은 소프트웨어가 작업하고 응답을 보내는 단일 호출에 해당하며 대부분 서버에서 수행하며 클라이언트는 기다린다.  
드믈게는 클라이언트가 응답을 받기전에 요청을 가로챌 수 있지만 이보다는 원래 요청을 방해하는 다른요청을 허용하는경우가 흔하다.  
클라이언트 관점에서 두 요청은 연결되어있지만 서버는 명확하지 않을 수 있다.

세션은 클라이언트 - 서버간 오랫동안 실행되는 상호작용이며 사용자가 논리적 흐름으로 생각하는 요청으로 이뤄지는경우가 많다.

운영체제와 관련된 중요한 용어 중 프로세스와 스레드가 있다.  
프로세스는 사용하는 내부 데이터에 대한 다단계 격리를 제공하는 대규모 실행컨텍스트다.  
스레드는 한 프로세스 내에서 여러 스레드로 작동할 수 있는 소규모 활성 에이전트다.  
스레드는 한 프로세스 안에서 여러 요청을 지원할 수 있어 효율적으로 자원을 사용할 수 있어 선호되지만
메모리를 공유하기 때문에 동시성 문제를 유발할 수 있으며 일부환경에서는 격리된 스레드를 제공한다.

실행 컨텍스트가 생각과는 다르게 깔끔하지 않다는것이다. 
이론상 각 세션은 프로세스와 독점적 관계를 맺으며 프로세스가 격리되므로 동시성 충돌을 줄이는데 유리하지만
프로세스를 시작하려면 많은 자원을 할당해야 하므로 거의 사용되지 않는 방식이다.


## 격리와 불변성
동시성 문제는 둘이상의 활성에이전트가 둘이상 동일한 데이터에 접근할 때 발생한다.  

격리를 통해 데이터를 분리해 하나의 활성 에이전트만 접근하도록 함으로써 해결할 수 있다.  
격리는 오류 발생 가능성을 낮추는 필수 기법이다. 이를 적절히 활용하면 프로그램을 격리환경으로 전환해 동시성
걱정없이 필요한 작업이 가능하며 훌륭한 동시성 설계란 격리 환경을 만드는 방법을 찾고 격리 환경내에서 최대한 많은
프로그래밍 작업을 수행하는 것이다.

동시성 문제는 공유 데이터가 수정될 수 있을때만 발생하므로 변경 불가능 데이터를 인식시켜 동시성 충돌을 예방할수있다.  
모든 데이터가 변경 불가능 할 수는 없지만 일부 데이터를 변경 불가능하게 하면 동시성문제의 우려를 줄이면서 공유할 수 있다.

## 낙관적 동시성 제어와 비관적 동시성 제어
격리할 수 없는 변경 가능한 데이터를 제어하는 두가지 방법이다.

낙관적 잠금  
두 사용자가 동시에 같은 파일을 편집하고 저장할때 먼저 저장한사람은 아무 문제없이 저장할수 있지만,
나중에 저장하는 사람은 동시성 제어 기능이 작동하여 충돌을 감지하여 나중에 저장하는사람이 해결법을 결정한다.  

비관적 잠금  
한사람이 파일을 편집하면 다른 사용자들은 편집이 완료될때까지 기다려야한다.

간단하게 보면 낙관적 잠금은 충돌감지, 비관적잠금은 충돌예방에 해당하고 낙관적잠금이 선호되는 경향이 있다. 

비관적 잠금의 단점은 동시성이 제한된다. 누군가 편집을 시작하면 다른사람들은 다 기다려야한다.

낙관적 잠금은 충돌이 일어났을때 나중에 편집을 완료한사람이 자신의 변경내용을 병합하고 새 버젼을 체크인해야한다. 

방법을 선택하는 중요한 기준은 충돌의 빈도와 심각도이다.  
충돌이 자주발생하지 않거나 결과가 심각하지 않다면 동시성을 위해 낙관적 잠금을 사용하지만, 결과가 심각한 경우에는 비관적 잠금을 사용한다.  

### 일관성 없는 읽기 예방
각각 다른 파일을 편집하고 저장하였지만 서로 연동되어 작동되는 파일을 수정한다는걸 모르면 공유된 파일은 동작하지 않는다. 이런 일관성없는 읽기 상황을 체크하지 못하는시스템은 수동으로 적용해주어야한다.

이 문제는 근본적으로 일관성 없는 읽기 문제지만 사람들은 동시성 문제에 의해 손실된 업데이트에 집중하느라 문제를 놓피는 경우가 많다. 그런데 비관적 잠금의 읽기 잠금과 쓰기 잠금을 활용하면 문제를 해결 할 수 있다.  
데이터를 읽으려면 읽기 잠금이 필요하며 쓰려면 쓰기 잠금이 필요하다. 여러 사용자는 동시에 읽기 잠금을 가질 수 있지만 읽기잠금을 가진 사람이있다면 쓰기 잠금을 가질 수 없고 쓰기 잠금을 가진 사용자가 있다면 다른사람들은 읽기 쓰기 잠금을 가질 수 없다. 이 비관적 잠금을 활용해 일관성 없는 읽기를 예방할 수도 있다. 

낙관적 잠금의 충돌감지는 일반적으로 데이터에 넣은 버젼 표식을 기반으로 작동하며 타임스탬프나 순차 카운터일 수 있다. 손실된 업데이트를 방지하기 위해 버젼표식을 공유된 데이터와 비교하고 동일한경우에만 업데이트를 허용한다.  
일관성 없는 읽기를 방지하는 방법도 비슷한데 모든 데이터의 버젼표식도 공유된 데이터와 비교하여 차이가있다면 충돌이 있다는 의미다.

일관성 읽기를 해결하는 또다른 방법은 임시 읽기 인데 읽은 모든 데이터에 타임스탬프나 읽기 전용라벨을 붙여 데이터베이스는 시간이나 라벨을 기준으로 데이터를 반환한다. 극히 드믄 소스코드 관리 시스템에서 이런 기능을 지원하기도하는데 데이터 원본에서 변경 전체 임시내역을 제공해야 하며 이를 위해서 시간과 공간이 많이 소비된다.이러한 방법에서는 snodgrass와 Fowler TP를 참고한다.

### 교착상태
비관적 잠금기법에서 발생할 수 있는 특수한 문제로 서로 연관된 다른 문서를 편집하면서 상대방이 잠금을 반환하길 무한히 대기하는것이다.  
이를 해결하는 방법 중 하나는 희생자 한명을 선택해 해당 사용자의 작업과 잠금을 포기해 다른사용자가 진행하게 하는것이다. 교착상태는 감지가 힘들고 희생자에게 큰 피해를 준다.  
비슷하게 모든 잠금에 시간을 두는 방식도있다. 감지 매커니즘보다 구현이 쉽지만 누군가는 희생자가 발생하게된다.

교착상태가 발생하지 않도록 하는 방법도 있다. 잠금을 가진사용자가 다른잠금을 얻을때 발생하므로 처음부터 모든 잠금을 얻고 추가하지 못하게하는것이다.

여러 기법을 함께 적용할 수도있다. 지나치게 조심스러워 보일수도 있지만 상태발생 후 처리보다는 현명하다.

## 트랜잭션
트랜잭션은 동시성을 처리하는 가장 중요한툴이다.  
시작과 끝이 명확하게 정의된 작업이며관련 자원은 모두 일관된 상태로 유지된다.  
또한 모든 트랜잭션은 전체를 실행하거나 실행하지 않는 양자택일로 수행해야한다.

### ACID
1. 원자성
  - 모두성공하거나 모두 실패하여 롤백되어야한다.
2. 일관성
  - 시스템자원은 시작과 완료시점에 모두 일관성있어야한다.
3. 격리성
  - 개별 트랜잭션 결과를 커밋하기전까지 다른 트랜잭션에서 볼 수 없어야한다.
4. 지속성
  - 트랜잭션결과는 영구적이어야한다.

### 트랜잭션 리소스
트랜잭션으로 동시성을 제어할 수 있는 모든 대상을 말하나 지금은 데이터베이스라고만 한다.

처리량 극대화를 위해 트랜잭션을 최대한 짧게만들고 여러 요청에 걸친 트랜잭션을 긴 트랜잭션이라고 한다.  
요청이 시작될 때 트랜잭션을 시작하고 끝날 때 트랜잭션을 끝내는 요청 트랜잭션이 일반적으로 많이 사용되며 다른방법으로 트랜잭션 밖에서 모든 읽기를 수행하고 업데이트할때 트랜잭션을 시작하는 지연 트랜잭션도 있지만 일관성없는 읽기를 유발하므로 어쩔수없는경우 아니면 잘 사용되지 않는다.

트랜잭션 사용시 어떤 리소스가 잠기는지 인식하여야한다. 여러 데이터베이스에서 작업시 트랜잭션은 관련 행을 잠가 여러 트랜잭션이 동일한 테이블에 접근할 수 있지만 전체 행을 잠그게 되면 처리 용량 이상으로 잠금이 진행되어 잠금 상향이 발생한다. 


### 활동성을 위한 트랜잭션 격리성 저하
활동성을 위해 트랜잭션의 보호 수준을 제한하는 경우도 흔하다. 완전격리가 가능하면 트랜잭션을 직렬화 할 수 있다. 여러 트랜잭션을 동시에 실행해도 순서대로 실행한경우와 같을경우 직렬화 가능 트랜잭션이라고 한다.   
대부분 트랜잭션 시스템은 sql표준을 사용해 네가지 격리 수준을 정의하며 직렬화 가능은 그 중 가장 각력한 수준이다. 아래 수준에서는 일관성없는 읽기가 발생할 수 있다. 

직렬화 가능 아래 첫번째 수준은 팬텀이 허용되는 반복 가능 읽기다. 팬텀이란 여러 요소를 추가했을때 읽는 쪽에서 일부 요소만 볼 수 있는 현상이다. 트랜잭션 일부에서는 유효하지만 전체에서는 유효하지 않아 발생하며 항상 삽입된 요소에서 팬텀이 발생한다.

그아래는 반복 불가능 읽기가 허용되는 커밋된 읽기다. 누군가의 업데이트 이후에는 원래의 읽기를 반복할 수 없다. 데이터베이스에서는 팬텀보다 반복 불가능 읽기를 찾기가 쉽기때문에 반복 가능한 읽기는 커밋된 읽기보다 정확성은 놉지만 활동성은 낮다.

가장 낮은 수준은 더티 읽기가 허용되는 커밋되지 않은 읽기다. 이 경우 커밋되지 않은 데이터를 읽을 수 있으며 트랜잭션이 롤백된경우 실제하지 않는 파일을 볼 수 있다.

정확성을 최대한 보장하려면 직렬화 가능 격리수준을 사용해야하지만 시스템의 활동성이 크게 저하되므로 적절한 균형을 찾는것이 중요하다.

### 비즈니스 트랜잭션과 시스템 트랜잭션
지금까지의 트랜잭션은 시스템 트랜잭션이며 RDBMS 시스템과 트랜잭션 모니터의 지원을 받아 운영된다.  
데이터 베이스 트랜잭션은 트랜잭션의 시작과 끝을 지정하는 명령되는 sql 명령그룹이다. sql명령 네개로 이루어진 트랜잭션중 마지막 트랜잭션이 무결성을 위반하면 모두 롤백시키고 트랜잭션 실패를 알려야하며 네개 모두 성공한 경우 결과를 순차적이아닌 한번에 공개하여야 한다.

RDBMS시스템과 서버 트랜잭션 관리자는 보편적으로 제공되고 자주활용되며 대부분의 개발자가 잘 이해할 수 있다. 하지만 시스템 트랜잭션은 비즈니스 시스템의 사용자에게는 전혀 의미가 없다. 사용자의 일련의 작업을 비즈니스 트랜잭션이라고 하며 ACID가 제공되어야 한다. 이를 제공하는 확실한 방법은 한 시스템 트랜잭션 안에서 실행하는 것이지만 대부분의 트랜잭션 시스템은 긴 트랜잭션을 잘 처리하지 못하며 병목 구간이 되어 확장성이 제약을 받고 짧은 트랜잭션으로 리팩터링은 복잡하다.

이렇게 긴 트랜잭션을 사용하기 어려운경우 짧은 트랜잭션으로 분리해야하는데 이경우 여러 시스템 트랜잭션 사이에서 ACID를 직접 지원하고 오프라인 동시성문제를 해결해야 한다.

원자성과 지속성은 비즈니스 트랜잭션에서 가장 쉽게 지원할 수있다. 사용자가 저장할때 비즈니스 트랜잭션 커밋단계를 하나의 시스템 트랜잭션 안에서 실행하는 방법으로 지원 할 수 있다.  
어플리케이션이 도메인 모델을 사용하는 경우 작업단위로 정확하게 추적할 수 있지만 비즈니스 논리를 트랜잭션 스크립트에 넣은경우 수동으로 변경사항을 추적하여야한다. 트랜잭션 스크립트를 사용하는것은 비즈니스 트랜잭션이 간단하다는 의미이기도 하므로 그리큰 문제가 되지 않는다.

비즈니스 트랜잭션에서 가장 적용하기 어려운 속성은 격리다. 격리에 실패하면 일관성에 실패한다.  
어플리케이션이 단일 트랜잭션 안에서 일관성을 유지하기 위해 해야하는 역활은 모든 사용가능한 비즈니스 규칙을 적용하는것이며 여러 트랜잭션에서 일관성을 유지하기 위해서는 세션이 다른세션의 변경 내용을 망치고 일관성이 깨져 사용자의 작업이 손실되지 않게 하는것이다.

## 오프라인 동시성 제어를 위한 패턴
가능하면 트랜잭션 시스템이 최대한 동시성 문제를 맡아서 처리하게 해야한다. 여러 시스템 트랜잭션에 걸친 동시성 제어에 손대게되면 동시성을 직접 해결해야하는 상황이 되면 예기치 못한 문제가 발생 할 수 있다.

비즈니스 트랜잭션과 시스템트랜잭션 간 불일치를 위해 직접 해결해야할 수 있으므로 몇가지 패턴을 소개하지만 꼭 필요할때만 사용하는것이 좋다.

첫번째는 낙관적 오프라인 잠금이다. 가장 구현이 쉽고 활동성이 높지만 비즈니스 트랜잭션이 실패할경우 커밋할 때 알수있으며 상당한 불편함을 초래할 수 있다.  
비관적 오프라인 잠금은 조기에 알아낼 수 있지만 구현이 어렵고 활동성이 어렵다.

이 두 방식을 사용할 때 모든 객체의 잠금을 직접 관리하지 않으면 복잡도를 크게 낮출 수 있다.  
굵은 입자 잠금을 이용하면 객체그룹의 동시성을 함께 관리할 수 있고 암시적 잠금을 사용하면 잠금을 직접 관리할 필요가 없을 뿐더러 어려운 버그도 예방할 수 있다.

낙관 또는 비관적 제어의 결정은 시스템의 사용자경험에 영향을 미치며 비관적 오프라인 잠금을 잘 설계하려면 도메인데 대한 정보를 충분히 얻어야한다. 마찬가지로 굵은 입자 잠금을 적절하게 선택하려면 도메인 지식이 필요하다.

## 어플리케이션 서버 동시성
지금까지는 데이터 원본에 실행되는 다중세션의 관점에서 동시성을 봤지만 다른 형태로 어플리케이션 서버자체의 프로세스 동시성이 있다.  
이 문제에서는 여러 동시요청을 어떻게 처리하며 설계에 어떤 영향을 미치는지 고려한다.  
어플리케이션 서버 동시성은 트랜잭션과는 관련이 없으므로 더이상 도움을 받을 수 없다.

잠금과 동기화 블록을 사용해 명시적 다중 스레드 프로그램을 제대로 구현하기는 매우 어려우며 찾기 아주 어려운 결함이 쉽게 발생하고 재현이 거의 불가능하다. 아주 적은 확률로 임의의 문제가 발생할 수 있으며 이를 디버깅하는것은 아주 고통스러우므로 동기화와 잠금을 명시적으로 처리하는경우는 최소화 하는것이 좋다.

간단한 방법은 세션별 프로세스를 사용하는것인데 프로세스의 상태가 다른 프로세스와 완전히 격리되므로 다중 스레드에 대해 신경 쓸 필요가 전혀 없고 메모리 격리 관점에서는 요청별로 새 프로세스를 시작하는것과 요청간에 프로세스를 요청간에 유휴 상태로 유지되는 세션에 연결하는 방법이 거의 동일한 효과가 있다.  
한가지 문제는 리소스 소모가 너무 많기 때문에 다른 세션의 여러 요청을 순차적으로 처리할 수 있도록 프로세스의 풀을 만들어 효율을 높이는 방법이 있다. 이처럼 요청 별 프로세스를 이용하면 적은 수의 프로세스를 사용해 비슷한 격리 수준을 유지하므로 까다로운 다중스레드 문제가 적지만 요청이 끝나면 처리될 때 사용한 모든 리소스를 반환하는것에 주의하여야하낟.

































