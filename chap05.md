# chap05
## 동시성
동시성은 소프트웨어 개발에서 가장 까다로운 측면 중하나다. 
문제의 원인을 미리 알기 어려워 해결이 힘들고 테스트하기도 어렵다.

트랜잭션은 까다로운 동시성의 여러 측면을 예방하는 프레임워크를 제공하므로 트랜잭션 내에서 조작을 수행하면 대부분 예방이 가능하다.
하지만 단일 트랜잭션에 넣을 수 없는 시스템과 상호 작용이 많기 때문에 완전히 무시할 수 없다.
여러 트랜잭션에 걸쳐 조작되는 경우 직접 동시성을 관리해야 하기 떄문이다.
여러 데이터베이스 트랜잭션에 걸쳐 조작되는 데이터에 대한 동시성제어를 오프라인 동시성이라고 한다.

또 다른 까다로운 문제는 다중 스레드 지원 서버 시스템인데 대처가 훨씬 수월하며 일부 서버 플랫폼은 거의자동으로 해결해준다.

이 책에서는 동시성 문제에 대한 해결책을 제안하는것이 아니다. 동시성 문제를 소개하고 오프라인 동시성을 해결하기위한 패턴을 소개하고
어플리케이션 서버 동시성에 대해 간단하게 알아본다. 또한 소스코드 관리 시스템을 예로 설명한다.

## 동시성문제
손실된 업데이트  
한사람이 파일을 수정하는동안 다른사람이 같은 파일을 수정하고 업데이트 한뒤에 업데이트하면 중간에 업데이트된 버젼을 
덮어쓰므로 이 내용은 사라지게된다.

일관성 없는 읽기  
한 사람이 데이터를 읽고 다른일을 처리하는 중 원본데이터가 업데이트 되었지만 일부만 추가로 읽는경우 발생한다.
업데이트 하기전 내용도아니고 업데이트 후 내용도 아닌 내용이되는데 이는 읽은 데이터에 일관성이 없기때문이다.

이 두 문제는 정확성을 위반하는 동작을 유발하지만 동시에 동일한 데이터를 사용하려고 하지 않는다면 발생하지않는다.
정확성만 중요하게 생각한다면 조율을 통해 한 사용자만 동시에 데이터를 사용할 수 있게 하면되지만 성능은 저하된다.

동시성이 얼마나 많이 진행될 수 있는지를 나타내는 활동성도 충족해야 하는데 필요성을 감안해 정확성을 양보하고 활동서을 향상시키는 경우도 있다.

## 실행 컨텍스트
외부 상호작용관점에서 중요한 컨텍스트 중 요청과 세션이 있다.  

요청은 소프트웨어가 작업하고 응답을 보내는 단일 호출에 해당하며 대부분 서버에서 수행하며 클라이언트는 기다린다.  
드믈게는 클라이언트가 응답을 받기전에 요청을 가로챌 수 있지만 이보다는 원래 요청을 방해하는 다른요청을 허용하는경우가 흔하다.  
클라이언트 관점에서 두 요청은 연결되어있지만 서버는 명확하지 않을 수 있다.

세션은 클라이언트 - 서버간 오랫동안 실행되는 상호작용이며 사용자가 논리적 흐름으로 생각하는 요청으로 이뤄지는경우가 많다.

운영체제와 관련된 중요한 용어 중 프로세스와 스레드가 있다.  
프로세스는 사용하는 내부 데이터에 대한 다단계 격리를 제공하는 대규모 실행컨텍스트다.  
스레드는 한 프로세스 내에서 여러 스레드로 작동할 수 있는 소규모 활성 에이전트다.  
스레드는 한 프로세스 안에서 여러 요청을 지원할 수 있어 효율적으로 자원을 사용할 수 있어 선호되지만
메모리를 공유하기 때문에 동시성 문제를 유발할 수 있으며 일부환경에서는 격리된 스레드를 제공한다.

실행 컨텍스트가 생각과는 다르게 깔끔하지 않다는것이다. 
이론상 각 세션은 프로세스와 독점적 관계를 맺으며 프로세스가 격리되므로 동시성 충돌을 줄이는데 유리하지만
프로세스를 시작하려면 많은 자원을 할당해야 하므로 거의 사용되지 않는 방식이다.


## 격리와 불변성
동시성 문제는 둘이상의 활성에이전트가 둘이상 동일한 데이터에 접근할 때 발생한다.  

격리를 통해 데이터를 분리해 하나의 활성 에이전트만 접근하도록 함으로써 해결할 수 있다.  
격리는 오류 발생 가능성을 낮추는 필수 기법이다. 이를 적절히 활용하면 프로그램을 격리환경으로 전환해 동시성
걱정없이 필요한 작업이 가능하며 훌륭한 동시성 설계란 격리 환경을 만드는 방법을 찾고 격리 환경내에서 최대한 많은
프로그래밍 작업을 수행하는 것이다.

동시성 문제는 공유 데이터가 수정될 수 있을때만 발생하므로 변경 불가능 데이터를 인식시켜 동시성 충돌을 예방할수있다.  
모든 데이터가 변경 불가능 할 수는 없지만 일부 데이터를 변경 불가능하게 하면 동시성문제의 우려를 줄이면서 공유할 수 있다.

## 낙관적 동시성 제어와 비관적 동시성 제어
격리할 수 없는 변경 가능한 데이터를 제어하는 두가지 방법이다.

낙관적 잠금  
두 사용자가 동시에 같은 파일을 편집하고 저장할때 먼저 저장한사람은 아무 문제없이 저장할수 있지만,
나중에 저장하는 사람은 동시성 제어 기능이 작동하여 충돌을 감지하여 나중에 저장하는사람이 해결법을 결정한다.  

비관적 잠금  
한사람이 파일을 편집하면 다른 사용자들은 편집이 완료될때까지 기다려야한다.

간단하게 보면 낙관적 잠금은 충돌감지, 비관적잠금은 충돌예방에 해당하고 낙관적잠금이 선호되는 경향이 있다. 

비관적 잠금의 단점은 동시성이 제한된다. 누군가 편집을 시작하면 다른사람들은 다 기다려야한다.

낙관적 잠금은 충돌이 일어났을때 나중에 편집을 완료한사람이 자신의 변경내용을 병합하고 새 버젼을 체크인해야한다. 

방법을 선택하는 중요한 기준은 충돌의 빈도와 심각도이다.  
충돌이 자주발생하지 않거나 결과가 심각하지 않다면 동시성을 위해 낙관적 잠금을 사용하지만, 결과가 심각한 경우에는 비관적 잠금을 사용한다.  

### 일관성 없는 읽기 예방
각각 다른 파일을 편집하고 저장하였지만 서로 연동되어 작동되는 파일을 수정한다는걸 모르면 공유된 파일은 동작하지 않는다. 이런 일관성없는 읽기 상황을 체크하지 못하는시스템은 수동으로 적용해주어야한다.

이 문제는 근본적으로 일관성 없는 읽기 문제지만 사람들은 동시성 문제에 의해 손실된 업데이트에 집중하느라 문제를 놓피는 경우가 많다. 그런데 비관적 잠금의 읽기 잠금과 쓰기 잠금을 활용하면 문제를 해결 할 수 있다. 




















