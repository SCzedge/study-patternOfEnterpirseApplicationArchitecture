# chap09 도메인 논리 패턴
## 트랜잭션 스크립트
트랜잭션 스크립트는 모든 논리를 단일 프로시저로 구성하고 데이터베이스를 호출한다.

### 작동원리
- 다른 프로그램과 마찬가지로 코드 모듈화 필요
- 다른 트랜잭션을 신경 쓸 필요가 없는것이 장점.
- 위치를 최대한 분리하여 최소 별도의 서브루틴을 사용하고 프레젠테이션논리 호출을 최소화해 수정 및 테스트를 용이하게 해야함

트랜잭션 스크립트 클래스 구성 방법  
1. 여러 트랜잭션을 한 클래스에 넣고 각 클래스에서 연관된 주제 영역 정의
2. 각 트랜잭션을 자체 클래스에 넣고 상위 형식정의 후 트랜잭션 스크립트 논리가 포함될 실행메소드 지정
  - 스크립트 인스턴스를 런타임 객체로 조작 가능

### 사용시점
- 트랜잭션 스크립트는 단순하므로 작은규모에 적합. 비즈니스 논리 복잡시 공통 코드 중복 등 설계가 복잡해짐.  
- 복잡한 비즈니스 도메인일 경우 도메인 모델을 사용해야 하나 리팩터링이 어려우므로 처음부터 도메인 모델로 설계 권장
- 트랜잭션 스크립트를 무조건적으로 배제하지 말고 단순한 문제는 빠르게 처리 할 것.

### 수익 인식 문제
자바를 사용한 트랜잭션 스크립트 예제 소개
- 도메인 모델과 비교할시 트랜잭션 스크립트 예제가 훨씬 간단하나 규칙 복잡도 증가시 해결 난이도 상승.

## 도메인 모델
비즈니스 논리는 매우 복잡할 수 있으며, 객체는 복잡성 처리를 위해 고안됨.

### 작동 원리
- 도메인 모델 구현과정은 비즈니스 영역 모델링 객체로 구성된 계층 구성 과정임.  
- 도메인 모델은 데이터베이스 모델과 비슷해 보이나 차이가 존재함
  - 데이터 프로세스가 혼합된 구조
  - 다중값 속성, 복잡한연결망 있음
  - 상속 사용
이때문에 주로 두가지 형식의 도메인 모델 사용
1. 단순 도메인 모델
  - 대부분 도메인 객체가 데이터베이스 테이블과 일치하므로 외형상 데이터베이스 설계와 비슷해보임
  - 활성 레코드 사용가능
2. 리치 도메인 모델
  - 상속, 전략, 다양한(gang of four)패턴, 상호 연결된 객체 연결망 포함
  - 복잡한 논리 표현에 적합하나 데이터베이스 매핑이 어려움
  - 데이터 매퍼 필요

비즈니스 동작 계층은 변경이 잦으므로 쉽게 수정 구축 테스트 할 수 있어야함.
  - 도메인 모델과 다른 계층간 결함을 최소화 한다.

도메인 모델은 다양한 범위 사용이 가능하다.
1. 파일에서 전체 객체를 읽어 메모리에 저장
  - 데스크탑 어플리케이션은 가능하지만 다중계층 IS 어플리케이션은 힘듬
  - 객체지향 데이터베이스 장점은 모든 객체가 메모리에 있는것 처럼 사용가능 하다는것.
2. 세션간 연관 객체만 가져오기
  - 모든 객체, 클래스가 포함되는것이 아님.
  - 어떤것을 가져올지는 데이터베이스 매핑 객체에 의해 결정됨

도메인 객체가 비대해질 시  
- 일반 동작 클래스와 사례별 클래스(트랜잭션스크립트, 프레젠테이션 등)로 분리할 수 있으나, 중복이 발생해 복잡성과 일관성 문제 발생가능.  
- 객체 비대화는 빈도가 낮으며 쉽게 찾고 수정할 수 있으므로 적당한 곳에 모두 넣는것이 좋음.

#### 자바구현
* J2EE 내 도메인 모델 개발 방법
- 도메인 논리가 복잡하지 않을 시 엔터티 빈을 도메인 모델로 사용해도 좋음.
- 상속, 전략 등 다른 패턴이 포함된 도메인 논리 사용시 POJO 도메인 모델과 데이터 매퍼 생성이 권장됨.

### 사용시점
시스템이 수행하는 동작의 복잡도에 따른다.
  - 유효성검사, 계산 등 복잡하고 변화하는 비즈니스 규칙 구현시 객체모델 사용이 권장.
  - 간단한 null처리, 합계 계산 등이 전부라면 트랜잭션 스크립트가 더 나을 수 있음.
  - 팀원의 도메인 객체 사용 숙련도나 러닝커브도 고려하여야함.

도메인 모델 사용시
  - 데이터베이스 매퍼 사용 시 도메인 모델을 데이터베이스에 독립적으로 유지 가능.
  - 데이터베이스 매퍼 사용 시 도메인 모델과 스키마가 분화되는 경우 대처에도 좋음.
  - 도메인 모델에 더 고유한 API적용시 서비스 계층 사용 고려.

### 참고자료
자바를 사용한 도메인 모델 소개 예제  
간단한 작업시에도 여러 클래스 상호작용
  - 특정 클래스를 찾는데 시간이 오래걸림
  - 복잡도 증가시 동작을 객체 안에 유지해 중복을 방지하고 결합을 줄이는 장점이 있음.

GOF패턴
  - 객체지향 패턴으로 작업 그룹을 작은 클래스 계층으로 결합할 수 있다.
  - 어플리케이션 확장이 가능한 조직화된 연결점 제공.

## 테이블 모듈
도메인 모델의 문제점 중 하나는 관계형 데이터 베이스와의 인터페이스가 까다롭다는 것이다.

테이블 모듈
  - 데이터베이스의 테이블 당 클래스 하나로 도메인 논리 구성.
  - 클래스의 한 인스턴스가 해당 데이터에 대한 여러 프로시저 포함
  - 도메인모델은 요청 수만큼 객체 사용, 테이블 모듈은 모든 요청을 객체 하나

### 작동원리
- 데이터와 동작을 하나로 묶으면서 관계형 데이터베이스의 장점 활용가능.
- 작업 대상 객체의 식별자 개념이 없음.
- 테이블 기반 기본 자료구조와 함께 사용이 일반적이며 레코드 집합에 저장됨.
- 동작을 테이블과 함께 그룹화해 대상 데이터를 묶는 캡슐화의 장점 제공.
- 작업시 여러 테이블 모듈의 동작이 요구됨

테이블 모듈이 인스턴스 하나인 경우
- 기존 레코드집합으로 테이블 모듈 초기화 가능
- 초기화 된 인스턴스로 레코드 집합의 행을 조작할 수 있고 상속을 적용할 수 있음.

테이블 데이터 게이트웨이 사용시  
1. 테이블 게이트 웨이 사용해 데이터로 레코드 집합조립
2. 레코드 집합을 인수로 테이블 모듈 생성(여러 테이블 모듈동작 필요시 동일 레코드집합 사용가능)
3.테이블 모듈은 레코드 집합에 비즈니스 논리 수행 및 수정된 레코드 집합 표시
4. 프레젠테이션 전달
5. 프레젠테이션에서 수정된 데이터 테이블 모듈로 전달 후 유효성검사
6. 데이터베이스 저장

테이블 데이터 게이트웨이 사용시 특징  
- 설계 내에 테이블 데이터 게이트웨이 클래스 및 매커니즘 포함되는 단점 발생
- 각 데이터원본마다 다른 테이블 게이트웨이를 사용하므로 다른 데이터원본에 사용가능한 장점
- 메모리에 레코드집합생성 후 데이터베이스 거치지 않고 테스트 가능
- 테이블은 뷰 및 쿼리를 포함한 가상의 테이블에 더 가까움

### 사용 시점
- 레코드 집합을 사용해 테이블 형식 데이터에 접근시 가장 적합.  
- 도메인 모델 객체와 테이블이 상대적으로 비슷하다면 활성 레코드를 사용하는 도메인 모델이 나을 수 있으나, 어플리케이션의 다른 부분이 테이블 기반 자료구조가 기반이라면 테이블 모듈이 더 잘 어울림.  
- 직접적인 인스턴스-인스턴스 관계 사용불가 및 다형성이 정상작동하지 않으므로 복잡한 작업에서 불리함.
- 테이블 기반 자료구조와 손쉬운 통합에 비해 복잡한 논리 처리 능력 저하

### 테이블 모듈을 이용한 수익 인식
C#을 사용한 테이블 모듈 인식

## 서비스 계층
작업 구현시 트랜잭션제어 및 응답 조율을 담당하며 비즈니스 논리를 캡슐화 한다.

### 작동원리
서비스 계층은 앞에 언급된 특성을 위반하지 않으면서 여러 방법으로 구현할 수 있다.
#### 비즈니스 논리
서비스 계층은 비즈니스 논리를 구성하기 위한 패턴 이며, 비즈니스논리는 도메인논리와 애플리케이션논리로 나눌 수 있다.  
1. 도메인논리
  - 순수한 문제 도메인을 집중적으로 처리
2. 애플리케이션 논리
  - 어플리케이션 역활 처리. 워크플로 논리라고도 함.

어플리케이션 논리를 순수 도메인 객체 클래스에 삽입시 부작용
1. 도메인 객체 클래스가 특정 어플리케이션 논리구현 및 사용시 도메인객체 클래스 재사용 힘듬
2. 두 종류의 논리를 동일 클래스에 넣으면 다시 구현하기가 힘듬.

서비스 계층은 비즈니스 논리를 별도계층으로 분리해 계층화의 장점 제공 및 순수도메인 객체클래스를 어플리케이션 간 재사용이 용이하도록 함

#### 구현의 변형
기본적인 변형으로 도메인 파사드 방식, 작업스크립트 방식이 있음.  

도메인 파사드 방식
- 서비스 계층을 도메인모델 위에서 씬 파사드 집합으로 구현
- 파사드 구현클래스는 비즈니스 논리를 구현하지 않고, 도메인모델이 비즈니스 논리 구현.
- 씬 파사드는 클라이언트 - 애플리케이션 상호작용의 작업 집합과 경계 형성.

작업 스크립트 방식  
- 서비스계층을 리치 클래스 집합으로 구현
- 애플리케이션 논리는 직접 구현, 도메인 논리는 캡슐화된 도메인 객체 클래스로 위임.  
- 작업 스크립트들은 주제별 클래스에 포함되어 서비스 계층의 클라이언트의 작업 요청 처리.
- 각 서비스 클래스들이 어플리케이 서비스 계층을 형성.
- 서비스 클래스는 역활과 공통 동작을 추상화 및 계층 상위 형식을 확장하여야함.

#### 원격호출에 대한 고려
- 서비스 계층클래스의 인터페이스는 정의상 굵은 입자 인터페이스이므로 원격 호출에 적합함.
- 객체를 분산해야 사용할 수 있는데 도메인 모델이 복잡할경우 상당히 힘든 작업이 됨.
- 원격이 필요한 경우 서비스 계층에 원격파사드를 넣거나 서비스 계층객체에서 원격인터페이스 구현.
- 웹기반 ui나 웹서비스 기반 통합 게이트웨이가 있는경우 별도 프로세스로 실행하지 않고 응답시간을 개선할 수 있음.

#### 서비스 및 작업 식별
- 서비스 계층 작업 식별의 시작은 애플리케이션의 유스 케이스 모델과 사용자 인터페이스 설계다.
- CRUD 유스케이스와 서비스 계층 작업간 거의 일대일 대응 관계가있다.
- 어플리케이션이 CRUD나 유효성 검사같은 유스케이스 실행시 서비스 계층 작업에 의해 조율되고 트랜잭션을 통해 원자성을 유지하여야 한다.

서비스 계층 추상화 식별 및 관련 작업그룹화
- 간단한 어플리케이션은 어플리케이션 이름을 딴 추상화 하나로도 충분.
- 대규모 어플리케이션은 보통 하위시스템으로 분할되며 이경우 하위시스템당 하나씩 하위시스템 이름을 딴 추상화가 선호된다.
- 대규모 어플리케이션 분할의 다른 방법으로 도메인 모델의 주요 분할을 반영하는 추상화가 있음.

### 자바 구현
- 도메인 파사드방식과 작업스크립트 방식 둘다 POJO나 상태비저장 세션빈으로 구현 가능
- 두 방법 다 테스트가 쉬우며 트랜잭션 제어가용이
- POJO는 EJB 컨테이너에 배포하지않아도 실행가능하므로 테스트가 쉬우나 분산 컨테이너 관리 트랜잭션 서비스 연결이 어려우며 서비스간 호출은 더 어렵다.
- EJB는 컨테이너 관리 분산 트랜잭션이 기본제공되지만 테스트 및 실행을 위해 컨테이너에 배포하여야함.

### 사용시점
서비스 계층의 장점은 어플리케이션 작업의 공통 집합을 정의하고 작업에대한 응답을 조율하는것이며 응답에는 원자성을 유지해야하는 어플리케이션 논리가 포함될 수 있다.  
1. 어플리케이션에 비즈니스 논리 사용 클라이언트가 둘이상
2. 유스케이스의 복잡한 응답에 여러 트랜잭션 리소스가 포함되는경우  
컨테이너 관리 트랜잭션과 함께 서비스 계층 활용이 합리적

비즈니스 사용 클라이언트가 한종류 이며, 유스케이스 응답에 여러 트랜잭션 리소스가 포함되지 않으면 페이지 컨트롤러로 트랜잭션을 수동제어하고 필요에 따라 데이터 원본계층으로 위임할 수 있으므로 서비스 계층이 필요하지 않으나 추후를 위해 처음부터 설계하는것이 좋을 수 있다.

### 수익인식
- 서비스 계층을 이용한 어플리케이션 논리 스크립팅방법과 서비스 계층작업에서 도메인 논리 위임방법 소개

J2EE플랫폼에서는 어플리케이션서비스를 트랜잭션 리소스를 사용하는 상태 비저장 세션 빈으로 구현해 EJB컨테이너가 분산트랜잭션을 관리하게 할 수 있다. 

이 예제는 서비스 계층이 작업 트랜잭션 응답 조율시 작업스크립팅과 도메인 객체클래스를 모두 사용함.
- 유스케이스에서 교우되는 애플리케이션 논리를 스크립팅 하지만 도메인 논리는 도메인 객체 클래스로 위임.
- 서비스 계층의 작업 스크립트내에 논리가 중복되지 않도록 하는 두가지 기법 소개

관찰차 패턴 사용시 다중 스레드 서비스 계층에서 구현이 어려우며 작업스크립트를 사용한 개방적인 코드가 더 명확하고 간단할 수 있음.

도메인 객체 메서드나 데이터 원본계층에 어플리케이션 논리 역활 구현시 서비스 계층이 필요하지 않을 수 있으나 권장되지 않음.
1. 도메인 객체클래스가 특정 어플리케이션 논리 구현시 재사용 힘듬
2. 어플리케이션 논리를 전용 목적의 상위 계층에 캡슐화 시 해당 계층 변경에 용이.

서비스 계층은 논리계층을 체계화 하기 위한 패턴으로 스크립팅과 도메인 객체클래스를 결합하고 장점을 활용할 수 있음.  
서비스 계층 구현에는 여러 변형이 있으며로컬이나 원격 호출이 가능하게 설계할 수 있다.   
패턴의 핵심은 비즈니스 논리 구현을 캡슐화 하고 다양한 클라이언트가 일관성 있게 호출 할 수 있게 하는것이다.








































