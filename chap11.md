# 객체 - 관계형 동작 패턴
## 작업단위
- 비즈니스 트랜잭션 중 데이터베이스에 영향을 미치는 변경내용을 추적하고 작업 완료시 데이터베이스에 기록.

### 작동원리
- 작업단위는 객체의 변경내용을 데이터베이스에 기록하기위해 추적하는 객체이다.
- 커밋시점에 해야 할일을 작업단위가 직접 결정한다.
- 데이터베이스 업데이트 메소드를 직접 실행하지 않고 작업단위가 트랜잭션을 열고 동시성검사 후 변경내용을 기록하므로 직접 작업순서를 조정할 필요가 없다.
- 추적을 위한 객체는 객체 호출자를 사용하거나 직접 할 수 있다.
- 호출자 등록은 객체 호출자가 객체를 작업단위에 등록. 등록하지 않으면 커밋시 등록하지 않음.
- 객체 등록은 등록메소드를 객체 매소드에 넣고 작업단위를 각 객체로 전달하거나 유지해야하며 적절할때 등록메소드를 호출하지 않으면 버그가 발생한다.
- 작업단위 컨트롤러는 작업단위가 모든 읽기를 처리하고 복사본을 만들어 수정시 복사본과 비교해 선택적으로 업데이트한다.
- 데이터베이스 업데이트 순서조율시 작업단위가 유용하다. 소규모 시스템은 외래키의존성을 바탕으로 코드를 명시하고, 대규모 시스템은 메타데이터를 사용하면 된다.
- 교착상태 최소화에도 활용할 수 있다. 모든트랜잭션이 편집테이블 순서를 동일하게 사용하면 교착상태 리스크가 크게 줄어든다.

### 사용시점
- 작업단위는 조작된 객체를 추적해 어떤 객체를 데이터베이스와 동기화해야하는지 알 수 있게해준다.
- 모든 객체를 명시적으로 저장 하는것은 간단하지만 데이터베이스 호풀을 많이 하게 될수 있다.
- 업데이트를 마지막으로 연기하면 과도한 데이터 베이스 호출은 방지하지만 모든 객체를 추적해야하며 변수가 늘어 관리하기 어려워진다. 트랜잭션스크립트에는 잘 어울리지만 도메인모델에는 어려울 수 있다.
- 객체에 더티플래그를 지정하고 트랜잭션이 끝날때 검사할 수 있다. 더티객체를 쉽게 찾을 수 있어야하며 도메인모델에서는 까다로울 수 있다.
- 작업단위는 여러 시스템 트랜잭션에 걸친 비즈니스 트랜잭션같이 복잡한 상황을 관리하기 위한 플랫폼이다.

## 식별자맵
- 동일한 데이터베이스 레코드에서 두개의 객체로 로드하고 두 객체를 업데이트하게되면 문제가 생긴다.
- 성능면에서도 원격호풀을 추가로 실행하므로 문제가 생길 수 있다.
- 식별자 맵은 단일 비즈니스 트랜잭션이 데이터베이스에서 읽은 모든 객체에 대한 기록을 보관해 이미 객체가 있는지 여부를 확인한다.

### 작동원리
- 데이터베이스 로드시 맵을 먼저 확인하여 일치하는객체가 있으면 반환하고 없으면 데이터베이스에서 읽고 맵에 저장한다.

#### 식별자 맵 사용시 고려사항
- 동시성관리와 상호작용하므로 낙관적 오프라인 잠금 고려
- 키의 선택 : 데이터베이스 테이블의 기본키가 확실하며 대체키도 가능하다.
- 명시적 또는 범용 : 키의 형식을 고려하여 맵을 명시할것인지 범용으로 할것인지도 선택해야 한다. 
  - 명시적 식별자 맵은 고유 메서드(findPersion(1))를 통해 접근하고 범용맵은 단일 메서드(find("person",1))를 통해 접근한다.
  - 범용맵 방식은 재사용가능한 객체로 지원이 가능하며 재사용 가능 레지스트리를 쉽게 만들 수 있다.
  - 명시적 식별자 맵은 컴파일 타입검사가 지원되며 가독성이 증가한다.
- 식별자 맵의 수 : 클래스당 하나 또는 전체 세션에 하나만 사용할지 결정해야 한다.
  - 세션에 하나는 데이터베이스 고유키가 있을 때만 사용할 수 있다. 한곳만 찾아보면 되며, 상속과 관련된 불편한선택과 테이블 추가시 맵을 추가할필요가 없다.
  - 클래스당 또는 테이블당 하나씩인경우 데이터베이스 스키마와 객체모델이 동일한 경우 적합하다.
- 식별자 맵의 위치 : 쉽게 찾을 수 있어야 하고 각 세션별로 격리되어야하므로 세션별 객체에 배치하여야한다. 작업단위가 있다면 최적이며, 없다면 레지스트리가 가장 적합하다.
  - 객체 데이터베이스를 트랜잭션 캐시로 사용하는경우와, 객체가 항상 읽기 전용인경우 식별자 맵을 세션당 하나씩 사용할 필요가 없다.

### 사용시점
- 식별자맵은 일관성없는 수정을 방지하기위해 객체 두개가 동일한 데이터베이스 레코드와의 연결을 막는데 사용된다.
- 데이터베이스 읽기 캐시로 동작해 접근을 줄이는 역활도 한다.
- 읽기 전용객체는 필요하지 않을 수 있는데 캐시를 통해 성능상 이득이 있으며 자바에서 잘못된형식의 동등검사를 예방할 수 있다.
- 의존 매핑에서는 식별자 맵이 필요하지않다. 부모가 지속성을 제어하므로 맵으로 식별자를 유지관리 할 필요가없다.
- 단일 세션내에서의 업데이트 충돌을 방지하지만 여러 세션간 충돌에 대해서는 아무 역활도 하지 못한다.

## 지연로드 
- 원하는 객체 로드시 연관 객체를 같이 가져오게하면 편리하지만 지나치게 많은 로드는 성능이저하될 수 있다.
- 지연로드는 객체 구조에 표시를 남겨 나중에 필요할때 로드할 수 있게 한다.

### 작동원리
- 지연초기화는 필드에 접근시 null값인 경우 계산후에 반환한다. 이를 위해서 필드를 자체 캡슐화해야하고 객체와 데이터베이스의 의존을 강제해 활성레코드, 테이블 데이터 게이트웨이에서 잘 작동한다.
- 지연초기화를 데이터매퍼와 같이 사용하려면 가상프록시라는 간접계층을 추가해야한다. 객체 처럼 생겼지만 해당 메서드중 하나가 호출되어야 데이터베이스에서 데이터를 로드한다.
- 가상프락시는 연결하려는 클래스마다 하나씩 많은 가상 프락시를 만들어야 하는 문제가 있다. 동적타입언어에서는 문제를 예방할 수 있지만 정적타입에서는 까다로울 수 있다.
- 값 홀더는 기본적으로 다른 객체를 래핑하며 처음 접근할 때만 데이터를 로드해 전달한다. 단점은 클래스가 값홀더가 있다는것을 알아야하며 엄격한 형식의 명시성이 손상된다.
- 고스트는 미완성 상태의 실제 객체로 처음 로드할때는 id만 포함되어있고 필드 접근시에 전체 상태가 로드된다.
- 고스트를 사용하는경우 바로 식별자맵에 넣으면 데이터를 읽을때 순환참조로 인한 문제를 예방할 수 있다.
- 가상프락시, 고스트도 완전히 빈상태일 필요는 없다. 사용이 빈번하거나 간단하게 가져올 데이터가있다면 가져오는것이 합리적이다.
- 지연로드는 데이터베이스 접근이 필요이상으로 늘수있다. 컬랙션을 지연로드로 채우고 한번에 하나씩 살펴볼때 물결로딩이 발생할 수 있다.
- 지연로드는 관점지향 프로그래밍과 잘 어울린다.

### 사용시점
- 지연로드의 사용 시점 결정시 객체 로드시 얼마나 많이 가져올지, 얼마나 데이터베이스 호출이 필요한지 알아야한다.
- 성능관점에서는 데이터를 가져오는 비용을 언제 지불할지 결정하는것이 중요하다. 한번의 호출로 모든것을 미리 가져오는것이 좋은경우도 많다.




























