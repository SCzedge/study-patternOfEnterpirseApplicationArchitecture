# chap06
## 세션상태
상태 비저장세션과 저장세션에 대한 논의는 비즈니스 트랜잭션과 시스템 트랜잭션 차이에서 시작되었다.  
일부 세션은 본질적으로 상태 저장이라는것을 인정하고 어떻게 처리할지 결정하는것이 중요하다.

## 상태 비저장의 가치
진정한 상태 비저장 객체란 필드가 없는 객체를 말하지만 보통 대부분은 요청간에 상태가 유지되지 않는 객체를 의미한다.  
사람들이 상태 저장 서버를 꺼려하는이유는 우선적으로 서버 리소스 문제가있다.  
상태저장 서버는 사용자를 대기하면서 모든 상태를 유지하여야 하지만, 상태 비저장서버 객체는 다른세션의 요청을 처리할 수 있다.  
상태를 저장할 필요가 없다면 어떤 객체로 요청을 처리하여도 상관없지만, 상태를 저장하려면 항상 같은 객체를 사용하여야한다는 것이며
더 많은 서버 객체가 필요하다는 뜻이다.  
또한 http가 상태 비저장 프로토콜이므로 웹과도 잘 맞는다.

하지만 모든것을 상태 비저장으로 처리할 수는 없다. 예를들면 장바구니 같은경우에는 사용자의 세션동안 유지되어야한다.

## 세션 상태
세션 상태는 특정 세션에만 해당되며 이 상태는 비즈니스 트랜잭션에 포함되어 다른 세션이나 비즈니스 트랜잭션과는 분리된다.  
세션 상태 데이터는 레코드 데이터(데이터베이스에 저장되는 장기 보존 데이터)와는 구분되며 커밋을 거쳐야 레코드 데이터가 된다.

세션 상태는 비즈니스 트랜잭션에 포함되므로 ACID같은 트랜잭션의 속성을 갖지만 사람들은 그에 따른 영향에 대해서는 잘 모르는 경우가 많다.

그 중 하나는 동시성이다. 사용자가 사용하는동안 현재 상태는 유효하지 않을 수 있다. 
값이 변경되고 요청을 통해 시스템으로 전송고서야 잘못된 값임을 알려줄 수 있다. 이러한 값은 세션 상태의 일부지만 유효하지 않으며
작업중이 아닌 커밋시에만 유효성검사를 받게된다.

가장 중요한 문제는 격리성이다. 
두 사용자가 동시에 편집하는 과정에서 사용자의 속성에 의해 값이 결정되는 레코드를 다른 사용자가 변경하게되ㅣ면 일관성 없는 읽기가 발생한다.

세션이 저장하는 모든 데이터가 세션상태인 것은 아니다. 꼭 저장할 필요는 없지만 성능 향상을 위해 캐싱 할 수 있다.  
세션상태는 올바른 동작을 위해 요청간에 저장해야 하지만, 캐시는 손실되어도 동작에 방해되지 않는다.

## 세션 상태를 저장하는 방법
### 클라이언트 세션 상태
데이터를 클라이언트에 저장한다. 
이를 위한 방법에는 url안에 데이터인코딩, 쿠키, 웹 양식의 숨겨진필드로 직렬화, 리치클라이언트 객체 저장 등이있다.

### 서버 세션 상태
요청간 데이터를 메모리에 저장하는 간단한 방법이 있으나 보통 세션상태를 직렬화 된 객체같이 더 안정적으로 저장할 수 있는 메커니즘을 사용한다.
객체는 서버 로컬파일 시스템이나, 데이터 원본에 저장할 수 있으며, 세션 id와 직렬화 된 객체가 각각 키-값인 간단한 db테이블일 수도 있다.

### 데이터 베이스 세션 상태
서버 쪽 저장소 이지만, 장기 데이터처럼 테이블과 필드로 분리하고 정제하여 저장하는 방식이다.

### 패턴의 선택 및 유의사항
클라이언트와 서버 간 필요 대역폭을 고려하여야한다.
클라이언트 세션 상태를 사용할경우 요청과 함께 세션데이터를 전송해야 하므로 데이터가 클경우 문제가 발생할 수 있다.
또한 클라이언트에서 필요하지 않더라도 서버에 필요한 데이터를 전송하게 되는데 보안과 무결성을 고려하지 않으면 무단으로 세션데이터가 편집되
심각한 범죄로 이어질 수 있다.

세션 데이터는 격리되어야 한다.
한 세션에서 일어나는 일은 다른 세션에 영향을 미치지 말아야한다. 이는 세션 밖에서는 세션 데이터에 접근 할 수 없어야 한다는것이며
데이터베이스 세션상태를 사용할때 저장된 레코드 데이터로부터 세션 데이터를 격리하기 위해 까다로운 작업이 필요하다는 것이다.

처리량 향상을 위해 클러스터링을 고려 할 수 있다. 
이경우 세션을 다른서버로 이동해 처리하고있으면 다른 서버가 요청을 처리하게 해주는 세션 마이그레이션 이 필요한지 생각해 보아야 하며
반대되는 개념은 한 서버가 특정 세션의 모든 요청을 처리하게 하는 서버 선호도이다.

세션 마이그레이션을 사용시 세션이 길게 유지되는경우 서버는 부하를 균형있게 배분 할 수 있지만 서버 세션 상태를 사용시 세션처리 시스템만 상태를
쉽게 찾을 수 있으므로 불편할 수 있다. 이를 해결하는 방법들이 있지만 데이터베이스 세션상태와 서버 세션상태 구분이흐려질 수 있다 

서버 선호도를 사용시 심각한 문제를 유발 할 수 있는데 시스템은 선호도를 보장하기위해 호출이 어떤 세션에 포함되는지 조사하지만
항상 조사할 수 있는것은 아니다. 
따라서 같은 IP의 클라이언트의 호출을 특정 서버로 몰아주게 되는데 프록시나 ISP의 IP 때문에 트래픽이 한서버에 집중될 수 있다.

서버가 세션 상태를 사용하려면 신속하게 사용할 수 있는 형태로 제공해야하는데 서버 세션상태의 경우 거의 바로 사용이 가능하다. 
클라이언트 세션 상태의 경우 바로 얻을 수 있지만 가공해야 하는 경우가 많다.
데이터베이스 세션 상태의 경우 데이터베이스에서 가져오고 형태를 가공해야한다.
각 방식은 시스템 응답성에 영향을 주며 소요되는 시간은 데이터의 크기와 복잡성에 따라 결정된다.

여러 숨은 문제 점 중 하나는 사용자가 세션을 취소하고 돌아오지 않을 수 있다. 
클라이언트 세션 상태는 이 경우 적합하나, 다른 패턴일 경우 이를 고려해 자동 시간 제한을 지원하여야한다.

클라이언트 강제종료, 서버오류, 네트워크 같은 시스템문제도 고려하여야하며 이러한 패턴을 구현하기 위한 개발 작업 난이도도 중요한 고려 사항이다
서버 세션 상태는 가장 쉽게 개발할 수 있으며, 요청간 상태를 지속할 필요가 없는경우 더 쉽다.
데이터베이스 세션 상태와 클라이언트 세션 상태는 일반적으로 세션 객체가 사용할 형식을 변환할 필요가 있다.
특히 데이터가 복잡하다면 신속하게 다른 여러 기능을 개발 할 수 없다는 의미다.

세 방식은 상호 배타적인 방식이 아니며 혼합하여 저장할 수 있으나 일반적으로 작업이 복잡해지는 경향이있으며
클라이언트 세션 상태패턴이 아닌 다른 방식을 사용하더라도 세션 식별자는 클라이언트 상태에 저장하여야한다.







2. 
